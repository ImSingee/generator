package utils

import (
	"fmt"
	"github.com/spf13/viper"
	"go/ast"
	"go/build"
	"go/parser"
	"strings"
)

type Function struct{}

type Functions map[string]*Function

var GENERATED_BY_GOD = CompileRegex(`^Code generated by god.* DO NOT EDIT\.`)

func GetFunctionsFromFileForStruct(f *ast.File, s *Struct) (Functions, error) {
	result := make(Functions, 0)

	for _, comment := range f.Comments {
		if GENERATED_BY_GOD.MatchString(comment.Text()) {
			return result, nil
		}
	}

	for _, decl := range f.Decls {
		funcDecl, ok := decl.(*ast.FuncDecl)

		if !ok || funcDecl.Recv == nil {
			continue
		}

		for _, field := range funcDecl.Recv.List {

			fieldType, err := GetStringFromPosition(field.Type.Pos(), field.Type.End())

			if err != nil {
				return nil, fmt.Errorf("cannot get receiver's type: %w", err)
			}

			if strings.HasPrefix(fieldType, "*") {
				fieldType = strings.TrimSpace(fieldType[1:])
			}

			if fieldType != s.Name {
				continue
			}

			result[funcDecl.Name.String()] = nil
		}
	}

	return result, nil
}

func GetFunctionsFromPackageForStruct(s *Struct) (Functions, error) {
	results := make(Functions, 0)

	pkgName := viper.GetString("gopackage")
	if pkgName == "" {
		return nil, fmt.Errorf("missing package name (gopackage config)")
	}

	// 获取包中所有的 Go 文件
	pkgInfo, err := build.ImportDir(".", 0)
	if err != nil {
		return nil, fmt.Errorf("cannot build from package: %w", err)
	}

	for _, filename := range pkgInfo.GoFiles {
		f, err := parser.ParseFile(fileSet, filename, nil, parser.ParseComments)

		if err != nil {
			return nil, fmt.Errorf("cannot parse file %s: %w", filename, err)
		}

		result, err := GetFunctionsFromFileForStruct(f, s)
		if err != nil {
			return nil, fmt.Errorf("cannot get functions from file %s: %w", filename, err)
		}

		for name, function := range result {
			results[name] = function
		}
	}

	return results, nil
}

// TODO
func GetFunctionsFromPackageForStructs(structs Structs) (map[*Struct]Functions, error) {
	results := make(map[*Struct]Functions, len(structs))

	return results, nil
}
